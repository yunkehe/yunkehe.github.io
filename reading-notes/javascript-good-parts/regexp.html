<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>正则表达式</title>
</head>
<body>
	<h1>正则表达式</h1>
	<p>
		非捕获性分组语法为(?:pattern),即将pattern部分组合成一个可统一操作的组合项，但不把这部分内容当作子匹配捕获，匹配的内容部进行编号也不存储在缓冲区中供以后使用。非捕获性分组方法在必须进行组合、但又不想对组合的部分进行缓存的情况下非常有用。
	</p>
	<p>
		例如，要在一篇英文资料中查找"program"和"project"两个单词，正则表达式可表示为/program|project/,也可表示为/pro(gram|ject)/，但是缓存子匹配(gramject)没有意义，就可以用/pro(?:gram|ject)/进行非捕获性匹配这样既可以简洁匹配又可不缓存无实际意义的字匹配。
	</p>
	<p>一个未被转移的 . 会匹配除行结束符以外的任何字符。</p>
	<ul class="test">
		<li data-t="1">你好</li>
		<li data-t="2">world</li>
	</ul>
</body>
<script type="text/javascript">
	var parse_url = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;
	var url = "http://www.ora.com:80/goodparts?q#fragment";
	var result = parse_url.exec(url);
	var names = ['url', 'scheme', 'slash', 'host', 'port', 'path', 'query', 'hash'];
	var blanks = '      ';
	var i;
	for (i = 0; i < names.length; i += 1) {
	    console.log("%s:%s%s", names[i], blanks.substring(names[i].length), result[i]);
	}

	var parse_1 = /^(?:())$/

	var tags = /[^<>]+|<(\/?)([A-Za-z]+)([^<>*])>/g;
	var text = '<ul class="test"><li data-t="1">你好</li><li data-t="2">world</li></ul>'

	while( (a = tags.exec(text))){
		for(var i = 0; i<a.length; i++){
			document.writeln(('// ['+i+'] '+ a[i]).entityify() );
		}
	}

</script>
</html>